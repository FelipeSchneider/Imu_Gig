function [ t, base_angle, top_angle ] = reconstructCinematic( com_vector, gig_const)
%[ t, base_angle, top_angle ] = reconstructCinematic( com_vector, dt )
% This function reconstructs the gig cinematics and its in a determinated 
%time acording to the set of commands that are send to the microcontroller
%   com_vector      The set of commands that will be send to the
%                   microcontroller. This vector is usually generated by
%                   the createComVector function and follows the protocol
%                   describe there
%   gig_const       The constants structure related to the gig
%   dt              time step between each position sample
%   t               output the time vector
%   base_angle      output the base angle for each time position
%   top_angle       output the top angle for each time position

%equations for the Uniformly Varied Moviment (still linear)
%   V = Vo + a*t;
%   S = So + Vo*t + (1/2)*a*t^2
%   V^2 = Vo^2 + 2*a*DS;
dt = 1/gig_const.acc_mod;
cnt = gig_const;
b_w = 0;
b_t = 0;
for i=1:4:length(com_vector)
    b_speed = com_vector(i);
    b_st = com_vector(i+1);         %programmed base steps
    t_speed = com_vector(i+2);
    t_st = com_vector(i+3);         %programmed top steps
    
    if(b_speed >= cnt.min_w)   %if the base motor will move at this command
        st_to_cruse_base = round((b_speed^2 - cnt.min_w^2)/(2*cnt.acc_mod*cnt.d_theta)); %   V^2 = Vo^2 + 2*a*DS;
        st_breaking_base = round((b_speed^2 - cnt.min_w^2)/(2*cnt.breaking_mod*cnt.d_theta)); %   V^2 = Vo^2 + 2*a*DS;
        
        %calculating the real cruse speed, number of steps to cruse... for BASE
        %motor
        if(b_st >= (st_to_cruse_base + st_breaking_base)) %if we have enough time to speed up and break, we can go up to the programmed speed
            st_start_breaking_base = b_st - st_breaking_base;      
        else %if we do not have enough steps to speed up to programmed speed, then we must reduce it
            st_to_cruse_base = b_st* (cnt.acc_mod/(cnt.acc_mod+cnt.breaking_mod));
            st_start_breaking_base = st_to_cruse_base;
            st_breaking_base = b_st - st_start_breaking_base;
            b_speed = sqrt(cnt.min_w^2 + 2*cnt.acc_mod*cnt.d_theta*st_to_cruse_base); %   V^2 = Vo^2 + 2*a*DS;
        end
        %calculating the duration of each phase
        t_speed_up_base = roots([cnt.acc_mod/2, cnt.min_w,  -st_to_cruse_base*cnt.d_theta]);
        t_speed_up_base = t_speed_up_base(t_speed_up_base>0);
        t_cruse_speed_base = (st_start_breaking_base-st_to_cruse_base)*cnt.d_theta/b_speed;
        t_breaking_base = roots([-cnt.breaking_mod/2, b_speed,  -st_breaking_base*cnt.d_theta]);
        t_breaking_base(t_breaking_base>0);
        t_breaking_base = min(t_breaking_base); %I have to get the smaller time, the bigger one corresponds to go futher and return to that desired position
        
        t1_b = 0:dt:(t_speed_up_base);
        t2_b = dt:dt:t_cruse_speed_base;
        t3_b = dt:dt:t_breaking_base;
        t_b = 0:dt:(t_speed_up_base+t_cruse_speed_base+t_breaking_base)-dt;
        b_w = [b_w cnt.min_w.*t1_b+(cnt.acc_mod/2).*t1_b.^2]; %   S = So + Vo*t + (1/2)*a*t^2
        w_aux = b_w(end);
        if(length(t2_b) > 0)                        %if there is a phase of constant speed:
            b_w = [b_w (w_aux+ b_speed.*t2_b)];
            w_aux = b_w(end);
        end
        b_w = [b_w (w_aux+ b_speed.*t3_b-(cnt.breaking_mod/2).*t3_b.^2)];
    else    %the base motor will not move, just make a delay
        
        
    end
    
    
    
    
    
    
    
    if(t_speed >= cnt.min_w)
        st_to_cruse_top = (t_speed^2 - cnt.min_w^2)/(2*cnt.acc_mod*cnt.d_theta);
        st_breaking_top = (t_speed^2 - cnt.min_w^2)/(2*cnt.breaking_mod*cnt.d_theta);
        
    %calculating the real cruse speed, number of steps to cruse... for TOP
    %motor
    if(t_st >= (st_to_cruse_top + st_breaking_top)) %if we have enough time to speed up and break, we can go up to the programmed speed
        st_start_breaking_top = t_st - st_breaking_top;      
    else %if we do not have enough steps to speed up to programmed speed, then we must reduce it
        st_to_cruse_top = t_st* (cnt.acc_mod/(cnt.acc_mod+cnt.breaking_mod));
        st_start_breaking_top = st_to_cruse_top;
        st_breaking_top = t_st - st_start_breaking_top;
        t_speed = sqrt(cnt.min_w^2 + 2*cnt.acc_mod*cnt.d_theta*st_to_cruse_top);
    end
    end
    
    
    
    
end  %FOR END


end

